
 // FOR 2 ADS1115

#include <Arduino.h>
#include <ADC_ADS1115.h>
#include "EasyNextionLibrary.h"  // Include EasyNextionLibrary 
#include <Adafruit_Sensor.h>
#include <DHT.h>
#include <WiFi.h>
#include "time.h"
#include <Ultrasonic.h>
//#include <Wire.h>
////////////////////////////////////   c02
#include <Wire.h>    // I2C library
#include "ccs811.h"  // CCS811 library

#include <iostream> //FOR WIFI CONNECTION FRON\M NEXTION (STRING TO CHAR)
#include <string>  //FOR WIFI CONNECTION FRON\M NEXTION (STRING TO CHAR)
///////////////////////////////////////////////////////////////////////////////
//#include <Servo.h>

//static const int GROWLIGHTPIN = 25;//GROW LIGHT PIN
int GROWLIGHTINTENSITY = 0 ;
//Servo SERVOGROWLIGHT;///GROW LIGHT COMMAND
////////////////////////////////////////////////////////////////////////////////////////////
// the number of the LED pin
const int ledPin = 25;  // 25 corresponds to GPIO25

// setting PWM properties
const int freq = 5000;
const int ledChannel = 0;
const int resolution = 8;
// Wiring for ESP8266 NodeMCU boards: VDD to 3V3, GND to GND, SDA to D2, SCL to D1, nWAKE to D3 (or GND)
//CCS811 ccs811(D3); // nWAKE on D3

// Wiring for Nano: VDD to 3v3, GND to GND, SDA to A4, SCL to A5, nWAKE to 13
//CCS811 ccs811(13); 

// nWAKE not controlled via Arduino host, so connect CCS811.nWAKE to GND
//CCS811 ccs811; 

// Wiring for ESP32 NodeMCU boards: VDD to 3V3, GND to GND, SDA to 21, SCL to 22, nWAKE to D3 (or GND)
CCS811 ccs811(23); // nWAKE on 23

uint16_t eco2, etvoc, errstat, raw;
///////////////////////////////////   co2

//const char* ssid     = "BlinkC4FCD6"; //   "Nassif el Rayess";
//const char* password = "0F1447EDED"; //   "Cooper_2019";  

const char* ntpServer = "pool.ntp.org";
const long  gmtOffset_sec = 7200;//3 hours for lebanon = 10800 OR 7200
const int   daylightOffset_sec = 3600;
void printLocalTime();// declare a function
////////////////////////////////////ULTRASOUND LEVEL START///////////////////////////////////////////
Ultrasonic ultrasonic(32, 33);// TRIGGER ECHO
int distance;
int WATERLEVEL;
//define sound speed in cm/uS
//#define SOUND_SPEED 0.034//WE MAY ADD TEMPERATURE CORRECTION
////////////////////////////////////ULTRASOUND LEVEL END///////////////////////////////////////////

DHT my_sensor(5,DHT22);// DHT22 ON GPIO5
////////////////////////////////////////////////////////////////////////////////////////////
EasyNex myNex(Serial2); // Create an object of EasyNex class with the name < myNex >

///////////////////////////////////////////////////////////////////////////////////////////////
ADC_ADS1115 ads(&Wire);
ADC_ADS1115 ads2(&Wire);

int16_t PH, EC, TDS, SPARECO2;//int16_t adc0, adc1, adc2, adc3;
int16_t UVLIGHT, GROWLIGHT, BVOLTAGE, BCURRENT;
//////////////////////////////////////////////////////////////////////////////////////////////
uint16_t VTEST;
float FPH;
float TEMPERATURE,HUMIDITY;
float PHVOLT = 0;
String DATETIME;

String SAVEDSSID;
String SAVEDPASSWORD;

int MONTHDAY;
int MONTH;
int YEAR;
int HOUR; 
int MIN;
int SEC;
int i=0;

int STRENGTH;// for wifi signal
//using namespace std;

void setup(void)
{
  Serial.begin(115200); 

    // configure LED PWM functionalitites
  ledcSetup(ledChannel, freq, resolution);
  
  // attach the channel to the GPIO to be controlled
  ledcAttachPin(ledPin, ledChannel);

  my_sensor.begin(); // FOR DHT 22
  myNex.begin(115200); // Begin the object with a baud rate of 9600
                     // If no parameter was given in the begin(), the default baud rate of 9600 will be used
  //rtc.setTime(30, 35, 10, 30, 8, 2021);//rtc.setTime(30, 24, 15, 17, 1, 2021);=== 17th Jan 2021 15:24:30
  delay(2000);        // Wait for Nextion to start
      // Connect to Wi-Fi
  myNex.writeStr("page WIFIIOT");// GOTO PAGE WIFIIOT
  delay(1000);    
  Serial.print("Connecting to ");
  SAVEDSSID = myNex.readStr("SAVEDSSID.txt");
  SAVEDPASSWORD = myNex.readStr("SAVEDPASSWORD.txt");
  Serial.println(SAVEDSSID);
  char ssid[SAVEDSSID.length()];
  char password[SAVEDPASSWORD.length()];
  int i;
    for (i = 0; i < sizeof(ssid); i++) {
        ssid[i] = SAVEDSSID[i];
    }
  int j;
    for (j = 0; j < sizeof(ssid); j++) {
        password[j] = SAVEDPASSWORD[j];
    }
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("");
  Serial.println("WiFi connected.");
  myNex.writeStr("page MONITOR");
// Init and get the time
  configTime(gmtOffset_sec, daylightOffset_sec, ntpServer);
  printLocalTime();

 ////////////////////////////////////////////////////////////////////////////////////////////////////////////// 

  ads.setAddr_ADS1115(ADS1115_IIC_ADDRESS0); // 0x48
  ads.setGain(eGAIN_TWOTHIRDS);              // 2/3x gain
  ads.setMode(eMODE_SINGLE);                 // single-shot mode
  ads.setRate(eRATE_128);                    // 128SPS (default)
  ads.setOSMode(eOSMODE_SINGLE);             // Set to start a single-conversion
  ads.init();

  ads2.setAddr_ADS1115(ADS1115_IIC_ADDRESS1); // 0x49
  ads2.setGain(eGAIN_TWOTHIRDS);              // 2/3x gain
  ads2.setMode(eMODE_SINGLE);                 // single-shot mode
  ads2.setRate(eRATE_128);                    // 128SPS (default)
  ads2.setOSMode(eOSMODE_SINGLE);             // Set to start a single-conversion
  ads2.init();

  ///////////////////////////////////////       CO2        ///////////////////////////////////////
  Serial.println("");
  Serial.println("setup: Starting CCS811 basic demo");
  Serial.print("setup: ccs811 lib  version: "); Serial.println(CCS811_VERSION);

  // Enable I2C
  Wire.begin(); 
  
  // Enable CCS811
  ccs811.set_i2cdelay(50); // Needed for ESP8266 because it doesn't handle I2C clock stretch correctly
  bool ok= ccs811.begin();
  if( !ok ) Serial.println("setup: CCS811 begin FAILED");

  // Print CCS811 versions
  Serial.print("setup: hardware    version: "); Serial.println(ccs811.hardware_version(),HEX);
  Serial.print("setup: bootloader  version: "); Serial.println(ccs811.bootloader_version(),HEX);
  Serial.print("setup: application version: "); Serial.println(ccs811.application_version(),HEX);
  
  // Start measuring
  ok= ccs811.start(CCS811_MODE_1SEC);
  if( !ok ) Serial.println("setup: CCS811 start FAILED");
///////////////////////////////////////       CO2        ///////////////////////////////////////
//SERVOGROWLIGHT.attach(GROWLIGHTPIN);
}

void loop(void)
{
  if (ads.checkADS1115())
  {
    
    PH = ads.readVoltage(0);
    Serial.print("PH:");
    Serial.print(PH);
    Serial.println("mV");
    PHVOLT = PH * 0.001;
    Serial.println(PHVOLT);
    FPH = -5.6548*PHVOLT + 15.509;
    Serial.println(FPH);

    EC = ads.readVoltage(1);////NOTE: EC IS TDS
    Serial.print("EC:");
    Serial.print(EC);
    Serial.println("mV");

    TDS = ads.readVoltage(2);//THIS IS SPARE ALSO
    Serial.print("TDS");
    Serial.print(TDS);
    Serial.println("mV");

    SPARECO2 = ads.readVoltage(3);
    Serial.print("SPARECO2:");
    Serial.print(SPARECO2);
    Serial.println("mV");
  }
  else
  {
    Serial.println("ADS1115 Disconnected!!!");
  }
  Serial.println("-----------------------------------");
  if (ads2.checkADS1115())
  {
    
    UVLIGHT = ads2.readVoltage(0);
    delay(50);
    //Serial.print("UVLIGHT:");//A0
    //Serial.print(UVLIGHT);
    //Serial.println("mV");

    GROWLIGHT = ads2.readVoltage(1);
    delay(50);
    //Serial.print("GROWLIGHT :");//A1
    //Serial.print(GROWLIGHT );
    //Serial.println("mV");

    BVOLTAGE = ads2.readVoltage(2);
    delay(50);
    //Serial.print("BVOLTAGE:");//A2
    //Serial.print(BVOLTAGE);
    //Serial.println("mV");

    BCURRENT = ads2.readVoltage(3);
    delay(50);
    //Serial.print("BCURRENT:");//A3
    //Serial.print(BCURRENT);
    //Serial.println("mV");
  }
  else
  {
    Serial.println("ADS1115 2 Disconnected!!!");
  }
  Serial.println("-----------------------------------");
   ///////////////////////////////////////////////ULTRASOUND LEVEL START///////////////////////////////////////////////////////////////
  while (i==10)
  {
  distance = ultrasonic.read();//ultrasonic.read();
  Serial.print("distance:");
  Serial.println(distance);
  i=11;//to get out of loop
  }
///////////////////////////////////////////////ULTRASOUND LEVEL END///////////////////////////////////////////////////////////////
///////////////////////////////////////////////   DHT22         ///////////////////////////////////////////////////////////////
  while (i==20)
  {
  HUMIDITY = my_sensor.readHumidity();
  Serial.print("HUMIDITY:");
  Serial.println(HUMIDITY);

  TEMPERATURE = my_sensor.readTemperature();
  Serial.print("TEMPERATURE:");
  Serial.println(TEMPERATURE);

  myNex.writeNum("HUMIDITY.val", HUMIDITY*10); 
  myNex.writeNum("TEMPERATURE.val", TEMPERATURE*10);

  i=0;
  Serial.println("HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH");
  }
///////////////////////////////////////////////   DHT22         ///////////////////////////////////////////////////////////////
///////////////////////////////////////////////   CO2         ///////////////////////////////////////////////////////////////
  // Read
  
  ccs811.read(&eco2,&etvoc,&errstat,&raw); 
  
  // Print measurement results based on status
  if( errstat==CCS811_ERRSTAT_OK ) { 
    Serial.print("CCS811: ");
    Serial.print("eco2=");  Serial.print(eco2);     Serial.print(" ppm  ");
    Serial.print("etvoc="); Serial.print(etvoc);    Serial.print(" ppb  ");
    //Serial.print("raw6=");  Serial.print(raw/1024); Serial.print(" uA  "); 
    //Serial.print("raw10="); Serial.print(raw%1024); Serial.print(" ADC  ");
    //Serial.print("R="); Serial.print((1650*1000L/1023)*(raw%1024)/(raw/1024)); Serial.print(" ohm");
    Serial.println();
  } else if( errstat==CCS811_ERRSTAT_OK_NODATA ) {
    Serial.println("CCS811: waiting for (new) data");
  } else if( errstat & CCS811_ERRSTAT_I2CFAIL ) { 
    Serial.println("CCS811: I2C error");
  } else {
    Serial.print("CCS811: errstat="); Serial.print(errstat,HEX); 
    Serial.print("="); Serial.println( ccs811.errstat_str(errstat) ); 
  }
///////////////////////////////////////////////   CO2         ///////////////////////////////////////////////////////////////

     myNex.writeNum("PH.val", FPH*10);
     myNex.writeNum("EC.val", EC*10);
     myNex.writeNum("TDS.val", TDS*10); 
     myNex.writeNum("CO2.val", eco2*10); 

     
     
     myNex.writeNum("UVLIGHT.val", UVLIGHT*10);
     myNex.writeNum("GROWLIGHT.val", GROWLIGHT*10);
     myNex.writeNum("BVOLTAGE.val", BVOLTAGE*0.0833*0.63);///////////////// CHECK EXCEL SHEET
     myNex.writeNum("BCURRENT.val", (BCURRENT*0.023)-25); ///////////////// CHECK EXCEL SHEET

     WATERLEVEL = distance; ///TO ADJUST FORMULA AS MECHANICAL CONSTRUCTION
     myNex.writeNum("WATERLEVEL.val", WATERLEVEL*10); 

     Serial.println("hello world");
     STRENGTH = WiFi.RSSI(); 
     Serial.println(STRENGTH );
     delay(100);//added to stabilize read from nextion
///////////////////////////////////////////////FOR TEST GOOD ///////////////////////////////////////////////////////////////////////
     VTEST = myNex.readNumber("VTEST.val");
     Serial.println(VTEST);
     //myNex.writeStr("page WIFIIOT");
     //delay(500);
     //SAVEDSSID = myNex.readStr("SAVEDSSID.txt");
     ///Serial.println("SAVEDSSIDSSSSSSSSSSSSSSSSSSSSS");
     //Serial.println(SAVEDSSID);
/////////////////////////////////////////////////FOR TEST //////////////////////////////////////////////////////////////////////
     printLocalTime();
     myNex.writeNum("MONTHDAY.val", MONTHDAY);
     myNex.writeNum("MONTH.val", MONTH); 
     myNex.writeNum("YEAR.val", YEAR);
     myNex.writeNum("HOUR.val", HOUR); 
     myNex.writeNum("MIN.val", MIN);
     myNex.writeNum("SEC.val", SEC);
     myNex.writeNum("STRENGTH.val", STRENGTH);  
    
  //delay(333);
  i = i+1;
  
} 

void printLocalTime(){
  struct tm timeinfo;
  if(!getLocalTime(&timeinfo)){
    Serial.println("Failed to obtain time");
    return;
  }
  Serial.println(&timeinfo, "%A, %B %d %Y %H:%M:%S");
  Serial.println(timeinfo.tm_mday);
  Serial.println(timeinfo.tm_mon+1);///////////////////////////ERRORE
  Serial.println(timeinfo.tm_year-100); /////////////ERRORE
  Serial.println(timeinfo.tm_hour);
  Serial.println(timeinfo.tm_min);
  Serial.println(timeinfo.tm_sec); 
  
  MONTHDAY = timeinfo.tm_mday;
  MONTH = timeinfo.tm_mon+1;
  YEAR = timeinfo.tm_year-100;
  HOUR = timeinfo.tm_hour; 
  MIN = timeinfo.tm_min;
  SEC = timeinfo.tm_sec;  
  //Serial.println(&timeinfo, "%A, %B %d %Y %H:%M:%S");
  //delay(5000);
  //Serial.print("Day of week: ");
  //Serial.println(&timeinfo, "%A");
  //Serial.print("Month: ");
  //Serial.println(&timeinfo, "%B");
  //Serial.print("Day of Month: ");
  //Serial.println(&timeinfo, "%d");
  //Serial.print("Year: ");
  //Serial.println(&timeinfo, "%Y");
  //Serial.print("Hour: ");
  //Serial.println(&timeinfo, "%H");
  //Serial.print("Hour (12 hour format): ");
  //Serial.println(&timeinfo, "%I");
  //Serial.print("Minute: ");
  //Serial.println(&timeinfo, "%M");
  //Serial.print("Second: ");
  //Serial.println(&timeinfo, "%S");
  GROWLIGHTINTENSITY = myNex.readNumber("CUSTOMIZE.GROWLIGHTINT.val");///GETTING REQUIRED VALUE FROM NEXTION
  ledcWrite(ledChannel, GROWLIGHTINTENSITY);
  //Serial.println(GROWLIGHTINTENSITY);
  //Serial.println("Time variables");
  //char timeHour[3];
  //strftime(timeHour,3, "%H", &timeinfo);
  //Serial.println(timeHour);
  //char timeWeekDay[10];
  //strftime(timeWeekDay,10, "%A", &timeinfo);
  //Serial.println(timeWeekDay);
  //Serial.println();
}   

